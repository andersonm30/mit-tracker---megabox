<script>

import { inject, onMounted, onBeforeUnmount, ref, provide, computed, watch, nextTick } from "vue";
import { GLOBAL_LEAFLET_OPT, WINDOW_OR_GLOBAL } from "@vue-leaflet/vue-leaflet/src/utils";
import { useStore } from "vuex";

// üéØ CLUSTER: CSS importados aqui (funcionam sem L global)
import 'leaflet.markercluster/dist/MarkerCluster.css';
import 'leaflet.markercluster/dist/MarkerCluster.Default.css';
// ‚ö†Ô∏è cluster.js PRECISA ser importado DEPOIS que L estiver dispon√≠vel (import din√¢mico no onMounted)

export default {
  name: 'Kore-CanvaMarker',
  props: {
    devices: { type: [Array, Object], default: () => [] },
    zoom: { type: Number, default: 10 },
    map: { type: Object, default: null },
    clustered: { type: Boolean, default: false },
  },
  // eslint-disable-next-line no-unused-vars
  setup(props, context) {

    // Debug mode - desative em produ√ß√£o (silencioso para n√£o poluir console)
    const DEBUG_MODE = false; // Altere para true apenas quando precisar debugar
    const debugLog = (...args) => DEBUG_MODE && console.log(...args);

    const store = useStore();

    // CLUSTER FIX: Usar clustered do store diretamente
    const isClusteredEnabled = computed(() => store.getters['mapPref']('clustered', false));

    debugLog('[CanvaMarker] Props:', props);

    let L = WINDOW_OR_GLOBAL.L;

    const leafletRef = ref([]);
    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);

    const addLayer = inject("addLayer");
    // PATCH 1C: Injetar registry do kore-map para registrar markers
    const markerRegistry = inject('deviceMarkerRegistry', null);
    //const options = {};

    const markerList = ref([]);

    // CLUSTER: Caches de markers e sistema de clustering (projeto argentino)
    const markerById = ref(new Map());         // deviceId -> marker
    const lastRenderToken = ref(0);
    // üéØ USAR window.$mk GLOBAL (como projeto argentino)
    window.$mk = window.$mk || null;
    // üéØ EXPOR markerById globalmente para que kore-map possa esconder/mostrar markers durante playback
    window.$markerById = markerById.value;
    let clusterAvailable = false; // üõ°Ô∏è Flag permanente: true se cluster inicializou com sucesso

    // Normalizar devices (Array, Object, {list: []})
    const normalizeDevices = (input) => {
      if (!input) return [];
      if (Array.isArray(input)) return input;
      if (typeof input === "object") {
        if (Array.isArray(input.list)) return input.list;
        return Object.values(input);
      }
      return [];
    };

    const bases = {}
    const color1 = {}
    const color2 = {}
    const sizes = {};
    const radius = {};
    const cached = {};
    // FIX: Track quando modelo est√° completo (base + color layers carregados)
    const modelReady = {};







    const imgCircleRed = document.createElement('img');
    imgCircleRed.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAABJmlDQ1BBZG9iZSBSR0IgKDE5OTgpAAAoz2NgYDJwdHFyZRJgYMjNKykKcndSiIiMUmA/z8DGwMwABonJxQWOAQE+IHZefl4qAwb4do2BEURf1gWZxUAa4EouKCoB0n+A2CgltTiZgYHRAMjOLi8pAIozzgGyRZKywewNIHZRSJAzkH0EyOZLh7CvgNhJEPYTELsI6Akg+wtIfTqYzcQBNgfClgGxS1IrQPYyOOcXVBZlpmeUKBhaWloqOKbkJ6UqBFcWl6TmFit45iXnFxXkFyWWpKYA1ULcBwaCEIWgENMAarTQZKAyAMUDhPU5EBy+jGJnEGIIkFxaVAZlMjIZE+YjzJgjwcDgv5SBgeUPQsykl4FhgQ4DA/9UhJiaIQODgD4Dw745AMDGT/0ZOjZcAAAACXBIWXMAAC4jAAAuIwF4pT92AAAHJmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuN2E3YTIzNiwgMjAyMS8wOC8xMi0wMDoyNToyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIyLjUgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMi0wMS0wNVQyMjoyMToxMy0wMzowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjItMDEtMDZUMTU6NDY6MjQtMDM6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjItMDEtMDZUMTU6NDY6MjQtMDM6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0iQWRvYmUgUkdCICgxOTk4KSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyOTVkNmEyZS05NDFhLTQ1NGItYjRhMS0yMDEzMjhmMDFiODIiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozYTk2NjAzMy0yMDZiLTI3NDgtYTU1Zi1jNDJiYTk3YmQ0ZWQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMjAxYjljMC1kYjcwLWE5NDgtOGYxNC03MjJkZGFiYWJhZjMiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjAyMDFiOWMwLWRiNzAtYTk0OC04ZjE0LTcyMmRkYWJhYmFmMyIgc3RFdnQ6d2hlbj0iMjAyMi0wMS0wNVQyMjoyMToxMy0wMzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIyLjUgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjb252ZXJ0ZWQiIHN0RXZ0OnBhcmFtZXRlcnM9ImZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmciLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjliNmI3Njg2LWFlY2MtNjE0NS05MGRjLTVmZDgxMjRhNzg2MyIgc3RFdnQ6d2hl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';

    const imgCircleGreen = document.createElement('img');
    imgCircleGreen.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAC4jAAAuIwF4pT92AAAG/mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuOWNjYzRkZSwgMjAyMi8wMy8xNC0xMToyNjoxOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIyLjUgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMi0wMS0wNVQyMjoyMToxMy0wMzowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjItMDctMTJUMTM6MTA6NDItMDM6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjItMDctMTJUMTM6MTA6NDItMDM6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmE0MWNiNmM4LWFiMWQtMmE0Ni1iMGU5LTRhNWJkZWYzYzY5NSIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmQ1ZjE5Nzc5LTVmMzMtZjM0Ny04Nzc3LTUwZjAwZDdiNWJjNCIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjAyMDFiOWMwLWRiNzAtYTk0OC04ZjE0LTcyMmRkYWJhYmFmMyI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDIwMWI5YzAtZGI3MC1hOTQ4LThmMTQtNzIyZGRhYmFiYWYzIiBzdEV2dDp3aGVuPSIyMDIyLTAxLTA1VDIyOjIxOjEzLTAzOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjIuNSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNvbnZlcnRlZCIgc3RFdnQ6cGFyYW1ldGVycz0iZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6OWI2Yjc2ODYtYWVjYy02MTQ1LTkwZGMtNWZkODEyNGE3ODYzIiBzdEV2dDp3aGVuPSIyMDIyLTAxLTA2VDE0OjE3OjI5LTAzOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjIuNSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmE0MWNiNmM4LWFiMWQtMmE0Ni1iMGU5LTRhNWJkZWYzYzY5NSIgc3RFdnQ6d2hlbj0iMjAyMi0wNy0xMlQxMzoxMDo0Mi0wMzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIzLjMgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNj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';

    const imgCircleYellow = document.createElement('img');
    imgCircleYellow.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAC4jAAAuIwF4pT92AAAG/mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuOWNjYzRkZSwgMjAyMi8wMy8xNC0xMToyNjoxOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIyLjUgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMi0wMS0wNVQyMjoyMToxMy0wMzowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjItMDctMTJUMTM6MTE6MDQtMDM6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjItMDctMTJUMTM6MTE6MDQtMDM6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmIzMjEzZmViLTUwMzUtZGI0NC04MjlhLWYyMGFjNzc1MWQ0NyIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmE4ZjdjZTdlLThjZGMtODQ0NS1iMzU2LWY4MzE5YWUwZjliMyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjAyMDFiOWMwLWRiNzAtYTk0OC04ZjE0LTcyMmRkYWJhYmFmMyI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDIwMWI5YzAtZGI3MC1hOTQ4LThmMTQtNzIyZGRhYmFiYWYzIiBzdEV2dDp3aGVuPSIyMDIyLTAxLTA1VDIyOjIxOjEzLTAzOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjIuNSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNvbnZlcnRlZCIgc3RFdnQ6cGFyYW1ldGVycz0iZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6OWI2Yjc2ODYtYWVjYy02MTQ1LTkwZGMtNWZkODEyNGE3ODYzIiBzdEV2dDp3aGVuPSIyMDIyLTAxLTA2VDE0OjE3OjI5LTAzOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjIuNSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmIzMjEzZmViLTUwMzUtZGI0NC04MjlhLWYyMGFjNzc1MWQ0NyIgc3RFdnQ6d2hlbj0iMjAyMi0wNy0xMlQxMzoxMTowNC0wMzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIzLjMgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNj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';



    const imgContorno = document.createElement('img');
    imgContorno.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAABJmlDQ1BBZG9iZSBSR0IgKDE5OTgpAAAoz2NgYDJwdHFyZRJgYMjNKykKcndSiIiMUmA/z8DGwMwABonJxQWOAQE+IHZefl4qAwb4do2BEURf1gWZxUAa4EouKCoB0n+A2CgltTiZgYHRAMjOLi8pAIozzgGyRZKywewNIHZRSJAzkH0EyOZLh7CvgNhJEPYTELsI6Akg+wtIfTqYzcQBNgfClgGxS1IrQPYyOOcXVBZlpmeUKBhaWloqOKbkJ6UqBFcWl6TmFit45iXnFxXkFyWWpKYA1ULcBwaCEIWgENMAarTQZKAyAMUDhPU5EBy+jGJnEGIIkFxaVAZlMjIZE+YjzJgjwcDgv5SBgeUPQsykl4FhgQ4DA/9UhJiaIQODgD4Dw745AMDGT/0ZOjZcAAAACXBIWXMAAC4jAAAuIwF4pT92AAAGWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuN2E3YTIzNiwgMjAyMS8wOC8xMi0wMDoyNToyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIyLjUgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMi0wMS0wNVQyMjoyMToxMy0wMzowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjItMDEtMDZUMTM6NTY6MzktMDM6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjItMDEtMDZUMTM6NTY6MzktMDM6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0iQWRvYmUgUkdCICgxOTk4KSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowYjUzMWZiYi02YmUzLTU3NGEtODFiOC1iOTNhODdmYzQwMzgiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDoxN2Y2ZmJiYy0zYTlhLTFhNGYtODc4OS1kZTE1ZTdkNTIxYzMiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphZGQxODU2Zi05NmE4LWFkNDItYjY2Yy01NTZkYmVkNTY3N2QiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmFkZDE4NTZmLTk2YTgtYWQ0Mi1iNjZjLTU1NmRiZWQ1Njc3ZCIgc3RFdnQ6d2hlbj0iMjAyMi0wMS0wNVQyMjoyMToxMy0wMzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIyLjUgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjb252ZXJ0ZWQiIHN0RXZ0OnBhcmFtZXRlcnM9ImZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmciLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjBiNTMxZmJiLTZiZTMtNTc0YS04MWI4LWI5M2E4N2ZjNDAzOCIgc3RFdnQ6d2hl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';

    const point = document.createElement("img");
    point.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGlmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuOWNjYzRkZSwgMjAyMi8wMy8xNC0xMToyNjoxOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIzLjIgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMi0wNC0wNFQxODoyMzoyOS0wMzowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wNy0yMlQxOTowNDo0MC0wMzowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjItMDctMjJUMTk6MDQ6NDAtMDM6MDAiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ZWZlYjdjMDQtYTE4MS0yYjQzLWExOTEtMWJmOTI4MjRlOTEyIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6MGMzNmYyM2ItMWQ5NS00OTQyLWE2ZDUtMzRkMGVkNzcxZDYzIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ZjlhMDM1NDktZTJkNC0xMjQ0LWI0MjYtMmE2OTgyMmYxMWFmIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZjlhMDM1NDktZTJkNC0xMjQ0LWI0MjYtMmE2OTgyMmYxMWFmIiBzdEV2dDp3aGVuPSIyMDIyLTA0LTA0VDE4OjIzOjI5LTAzOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjMuMiAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA4Y2YzMzAzLTcwNWQtYjA0Zi1iMGE3LTg0ODIzMDE1OTc2OCIgc3RFdnQ6d2hlbj0iMjAyMi0wNC0wNFQxODoyMzoyOS0wMzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIzLjIgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDplZmViN2MwNC1hMTgxLTJiNDMtYTE5MS0xYmY5MjgyNGU5MTIiIHN0RXZ0OndoZW49IjIwMjItMDctMjJUMTk6MDQ6NDAtMDM6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMy4zIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5hrBreAAAHv0lEQVRogc2a23MT9xXHP0crybYUsA3mFq8cyzdh2ZK5+BaD8d0SEBpMk5RS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";





    // üõ°Ô∏è MELHORIA: Carregamento de modelos com timeout e error handling robusto
    // Previne travamento se imagens n√£o carregarem ou demorarem muito
    function loadModel(key, model, c1, c2, w, d = 20) {
      return new Promise((resolve, reject) => {
        const TIMEOUT = 10000; // 10 segundos - timeout para carregamento
        let timeoutId;

        const cleanup = () => {
          if (timeoutId) clearTimeout(timeoutId);
        };

        // Timeout handler
        timeoutId = setTimeout(() => {
          console.error(`[CanvaMarker] Timeout ao carregar modelo: ${key}`);
          cleanup();
          reject(new Error(`Timeout loading model: ${key}`));
        }, TIMEOUT);

        bases[key] = document.createElement('img');
        bases[key].src = '/img/cars/' + model + '_base.png';
        
        // Error handler para base image
        bases[key].onerror = () => {
          console.error(`[CanvaMarker] Erro ao carregar base: ${model}`);
          cleanup();
          resolve(); // Resolve mesmo com erro para n√£o travar
        };

        sizes[key] = w;
        radius[key] = d;

        bases[key].onload = () => {
          if (c1) {
            color1[key] = document.createElement('img');
            color1[key].src = '/img/cars/' + model + '_color1.png';
            
            color1[key].onerror = () => {
              console.error(`[CanvaMarker] Erro ao carregar color1: ${model}`);
              cleanup();
              modelReady[key] = true;
              resolve();
            };
            
            color1[key].onload = () => {
              if (c2) {
                color2[key] = document.createElement('img');
                color2[key].src = '/img/cars/' + model + '_color2.png';
                
                color2[key].onerror = () => {
                  console.error(`[CanvaMarker] Erro ao carregar color2: ${model}`);
                  cleanup();
                  modelReady[key] = true;
                  resolve();
                };
                
                color2[key].onload = () => {
                  cleanup();
                  modelReady[key] = true;
                  resolve();
                }
              } else {
                cleanup();
                modelReady[key] = true;
                resolve();
              }
            }
          } else {
            cleanup();
            modelReady[key] = true;
            resolve();
          }
        }
      });
    }


    function generateCachedName(name) {
      var c = document.createElement('canvas');
      var ctx = c.getContext('2d');

      ctx.font = "11px Trebuchet Ms";
      ctx.textAlign = "center";

      const tSize = (ctx.measureText(name).width + 10);

      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.fillRect(0, 0, tSize, 20);

      ctx.fillStyle = 'white';
      ctx.fillText(name, tSize / 2, 13);


      return { c: c, width: tSize };
    }

    function generateCachedLabel(device) {

      const name = device.name;
      const plate = device.attributes['placa'] || 'N/A';
      const all = name + " - " + plate;


      return {
        name: generateCachedName(name),
        plate: generateCachedName(plate),
        all: generateCachedName(all),
      }

    }

    function generateCachedModel(key, h1, s1, b1, h2, s2, b2) {

      if (!bases[key]) {
        return null; // FIX: Retornar null ao inv√©s de false
      }
      var c = document.createElement('canvas');

      c.width = sizes[key];
      c.height = sizes[key];

      var ctx = c.getContext('2d');



      ctx.drawImage(bases[key], 0, 0, (sizes[key]), (sizes[key]));


      /* IFTRUE_myFlag */
      if (color1[key]) {


        //c.style = 'filter: hue-rotate('+h1+'deg) saturate('+s1+') brightness('+b1+')';
        ctx.filter = 'hue-rotate(' + h1 + 'deg) saturate(' + s1 + ') brightness(' + b1 + ')';
        ctx.drawImage(color1[key], 0, 0, (sizes[key]), (sizes[key]));
      }

      if (color2[key]) {
        ctx.filter = 'hue-rotate(' + h2 + 'deg) saturate(' + s2 + ') brightness(' + b2 + ')';
        ctx.drawImage(color2[key], 0, 0, (sizes[key]), (sizes[key]));
      }

      /* FITRUE_myFlag */

      // FIX: Resetar ctx.filter para n√£o vazar para outros draws
      ctx.filter = 'none';

      return c;
    }

    // üõ°Ô∏è MELHORIA: Cache com limite de tamanho (LRU-like)
    const MAX_CACHE_SIZE = 500;
    const cacheAccessOrder = [];

    function getCachedModel(key, h1, s1, b1, h2, s2, b2) {
      // Valida√ß√£o de entrada
      if (!key || typeof key !== 'string') {
        console.warn('‚ö†Ô∏è [CanvaMarker] getCachedModel: key inv√°lida');
        return null;
      }
      
      const cKey = key + '|' + h1 + '|' + s1 + '|' + b1 + '|' + h2 + '|' + s2 + '|' + b2;

      // FIX: N√£o cachear se modelo ainda n√£o est√° pronto
      if (!modelReady[key]) {
        return null;
      }

      // Se j√° existe no cache, atualizar ordem de acesso
      if (cached[cKey]) {
        const idx = cacheAccessOrder.indexOf(cKey);
        if (idx > -1) {
          cacheAccessOrder.splice(idx, 1);
        }
        cacheAccessOrder.push(cKey);
        return cached[cKey];
      }

      // Gerar novo canvas
      const tmp = generateCachedModel(key, h1, s1, b1, h2, s2, b2);
      if (!tmp) return null;

      // Limitar tamanho do cache
      if (Object.keys(cached).length >= MAX_CACHE_SIZE) {
        const oldestKey = cacheAccessOrder.shift();
        if (oldestKey) {
          delete cached[oldestKey];
          debugLog(`[CanvaMarker] Cache evicted: ${oldestKey}`);
        }
      }

      cached[cKey] = tmp;
      cacheAccessOrder.push(cKey);
      return tmp;
    }



    //const showName = ref(store.getters['mapPref']('name'));
    //const showPlate = ref(store.getters['mapPref']('plate'));
    const showStatus = computed(() => store.getters['mapPref']('status'));

    // CLUSTER PATCH: Fun√ß√µes de render e limpeza
    const clearAllMarkers = () => {
      // Remove markers individuais
      for (const [, m] of markerById.value) {
        try { if (m.remove) m.remove(); } catch (e) { /* cleanup */ }
      }
      markerById.value.clear();

      // üéØ CLUSTER: Limpar window.$mk
      if (window.$mk) {
        try { window.$mk.clearLayers(); } catch (e) { /* cleanup */ }
      }
    };

    // üéØ CLUSTER FIX: Substituir makeClusterCanvas e addClusterMarker
    // Agora L.MarkerClusterGroup cria os clusters automaticamente

    const renderClustered = (devices, token) => {
      // üõ°Ô∏è GUARD: Verificar se window.$mk existe e est√° no mapa
      if (!window.$mk || !window.$mk._map) {
        console.warn('[CanvaMarker] window.$mk inv√°lido (sem _map), abortando renderClustered');
        return;
      }
      
      const mapProxy = props.map;
      if (!mapProxy) return;
      const map = mapProxy.leafletObject || mapProxy;
      if (!map) return;

      // Limpar cluster anterior
      try {
        window.$mk.clearLayers();
      } catch (e) {
        console.warn('[CanvaMarker] Erro ao limpar window.$mk:', e);
        return;
      }
      
      invalidDevices.count = 0;
      invalidDevices.ids = [];

      // Adicionar markers ao cluster
      for (const d of devices) {
        if (token !== lastRenderToken.value) return;

        const marker = addDevice(d);  // Retorna L.CanvasMarker
        if (marker) {
          try {
            window.$mk.addLayer(marker);
          } catch (e) {
            console.warn('[CanvaMarker] Erro ao adicionar marker ao cluster:', e);
          }
        }
      }

      // Log consolidado de devices inv√°lidos
      if (invalidDevices.count > 0) {
        const summary = invalidDevices.count > 5 
          ? `${invalidDevices.ids.slice(0, 5).join(', ')} e mais ${invalidDevices.count - 5}`
          : invalidDevices.ids.join(', ');
        console.warn(`‚ö†Ô∏è [CanvaMarker] ${invalidDevices.count} device(s) com posi√ß√£o inv√°lida: ${summary}`);
      }

      // Adicionar cluster ao mapa se ainda n√£o est√°
      if (!map.hasLayer(window.$mk)) {
        try {
          map.addLayer(window.$mk);
        } catch (e) {
          console.warn('[CanvaMarker] Erro ao adicionar window.$mk ao mapa:', e);
        }
      }
    };

    const renderIndividual = (devices, token) => {
      invalidDevices.count = 0;
      invalidDevices.ids = [];

      for (const d of devices) {
        if (token !== lastRenderToken.value) return;
        addDevice(d);
      }

      // Log consolidado de devices inv√°lidos
      if (invalidDevices.count > 0) {
        const summary = invalidDevices.count > 5 
          ? `${invalidDevices.ids.slice(0, 5).join(', ')} e mais ${invalidDevices.count - 5}`
          : invalidDevices.ids.join(', ');
        console.warn(`‚ö†Ô∏è [CanvaMarker] ${invalidDevices.count} device(s) com posi√ß√£o inv√°lida: ${summary}`);
      }
    };

    // üõ°Ô∏è MELHORIA: Debounce para evitar re-renders excessivos
    let syncTimeout = null;
    const syncMarkers = async () => {
      // Cancelar sync anterior se ainda pendente
      if (syncTimeout) {
        clearTimeout(syncTimeout);
      }

      // Debounce de 100ms - evita updates r√°pidos desnecess√°rios
      return new Promise(resolve => {
        syncTimeout = setTimeout(async () => {
          const startTime = performance.now();
          const map = props.map;
          if (!map) {
            resolve();
            return;
          }

          // Usa devices do store diretamente, pois o componente n√£o recebe props.devices
          const storeDevices = store.state.devices?.deviceList;
          const storePositions = store.state.devices?.positionsList;
          const rawDevices = normalizeDevices(storeDevices);
          
          // üîß FIX: Juntar device com sua posi√ß√£o (positionsList[deviceId])
          // O device n√£o tem lat/lng, a posi√ß√£o est√° em positionsList
          const devices = rawDevices.map(d => {
            const pos = storePositions?.[d.id];
            return {
              ...d,
              latitude: pos?.latitude,
              longitude: pos?.longitude,
              course: pos?.course ?? 0,
              speed: pos?.speed ?? 0,
              attributes: { ...d.attributes, ...(pos?.attributes || {}) }
            };
          });
          const token = ++lastRenderToken.value;

          // üéØ CLUSTER: Gerenciar window.$mk baseado no modo (projeto argentino)
          const mapObj = map.leafletObject || map;

          // üõ°Ô∏è GUARD PERMANENTE: Se cluster nunca foi dispon√≠vel, for√ßar modo individual
          if (isClusteredEnabled.value && !clusterAvailable) {
            console.warn('‚ö†Ô∏è [CanvaMarker] Cluster solicitado mas nunca inicializou, for√ßando modo individual');
            isClusteredEnabled.value = false; // ‚úÖ Desabilitar no store tamb√©m
          }

          if (isClusteredEnabled.value && window.$mk && clusterAvailable) {
            // Modo cluster: usar window.$mk (L.MarkerClusterGroup)
            // üéØ CR√çTICO: Garantir que cluster est√° no mapa
            if (!mapObj.hasLayer(window.$mk)) {
              try {
                mapObj.addLayer(window.$mk);
                console.log('‚úÖ [CanvaMarker] window.$mk re-adicionado ao mapa');
              } catch (e) {
                console.error('‚ùå [CanvaMarker] Erro ao re-adicionar window.$mk:', e);
              }
            }
            
            // Remover markers individuais se existirem
            for (const [, m] of markerById.value) {
              try { 
                if (mapObj.hasLayer(m)) mapObj.removeLayer(m);
              } catch (e) { /* cleanup */ }
            }
            markerById.value.clear();

            renderClustered(devices, token);
          } else {
            // Modo individual: remover cluster e adicionar direto
            if (window.$mk && mapObj.hasLayer(window.$mk)) {
              try {
                mapObj.removeLayer(window.$mk);
                window.$mk.clearLayers();
              } catch (e) { /* cleanup silencioso */ }
            }
            clearAllMarkers();
            renderIndividual(devices, token);
          }
          
          const elapsed = (performance.now() - startTime).toFixed(2);
          if (elapsed > 100) {
            console.warn(`‚ö†Ô∏è [CanvaMarker] syncMarkers lento: ${elapsed}ms (${devices.length} devices)`);
          }
          resolve();
        }, 100);
      });
    };


    onMounted(async () => {
      debugLog('üîß [CanvaMarker] Iniciando onMounted...');
      
      L = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await import("leaflet/dist/leaflet-src.esm");

      debugLog('‚úÖ [CanvaMarker] Leaflet carregado');

      L.interpolatePosition = function (p1, p2, duration, t) {
        var k = t / duration;
        k = (k > 0) ? k : 0;
        k = (k > 1) ? 1 : k;
        return L.latLng(p1.lat + k * (p2.lat - p1.lat),
          p1.lng + k * (p2.lng - p1.lng));
      };




      L.Canvas.include({
        _updateImg(layer) {
          const { img } = layer.options;
          const p = layer._point.round();


          if (layer.options.type === 'pointer') {
            if (img.rotate) {
              this._ctx.save();

              this._ctx.translate(p.x, p.y);
              this._ctx.rotate(img.rotate * Math.PI / 180);

              this._ctx.drawImage(point, -(20) / 2, -(20) / 2, (20), (20));


              this._ctx.restore();
            } else {

              this._ctx.save();
              this._ctx.translate(p.x, p.y);

              this._ctx.drawImage(point, -(20) / 2, -(20) / 2, (20), (20))
              this._ctx.restore();
            }
          } else {
            // üéØ Renderiza√ß√£o de ve√≠culos (CanvasMarker)

            // PATCH FINAL A: Skip se marker est√° escondido (playback)
            if (layer.options.__hidden) {
              return false;
            }

            const zFactor = (layer._map._zoom - 4) * 0.05;

            const status = layer.options.status || 'unknown';


            if (img.hide || img.hidden) {
              return false;
            }



            this._ctx.save();
            this._ctx.translate(p.x, p.y);





            /*
          if (layer.options.isCtrlPressed || showName.value || showPlate.value) {

            this._ctx.font = "11px Arial";
            this._ctx.textAlign = "center";

            let n = [];

            if(layer.options.isCtrlPressed || showName.value){
              n.push(layer.options.name);
            }

            if((layer.options.isCtrlPressed || showPlate.value) && store.state.devices.deviceList[layer.options.id].attributes['placa']){
              n.push(store.state.devices.deviceList[layer.options.id].attributes['placa']);
            }

            const tSize = (this._ctx.measureText(n.join(" - ")).width + 10);

            this._ctx.fillStyle = 'rgba(0,0,0,0.8)';
            this._ctx.fillRect(-((tSize) / 2), layer.options.radius - 50, tSize, 20);



            this._ctx.fillStyle = 'white';

            this._ctx.fillText(n.join(" - "), 0, layer.options.radius - 36);
          }*/

            if (layer.options.isCtrlPressed || showStatus.value) {
              if (status === 'online') {
                this._ctx.drawImage(imgCircleGreen, -(40 * (img.rSize + zFactor)) / 2, -(40 * (img.rSize + zFactor)) / 2, (40 * (img.rSize + zFactor)), (40 * (img.rSize + zFactor)));
              } else if (status === 'offline') {
                this._ctx.drawImage(imgCircleRed, -(40 * (img.rSize + zFactor)) / 2, -(40 * (img.rSize + zFactor)) / 2, (40 * (img.rSize + zFactor)), (40 * (img.rSize + zFactor)));
              } else {
                this._ctx.drawImage(imgCircleYellow, -(40 * (img.rSize + zFactor)) / 2, -(40 * (img.rSize + zFactor)) / 2, (40 * (img.rSize + zFactor)), (40 * (img.rSize + zFactor)));
              }

            }

            if (img.rotate) {
              this._ctx.rotate(img.rotate * Math.PI / 180);
            }

            // FIX: Verificar se canva existe antes de desenhar; usar placeholder se n√£o
            if (img.canva) {
              this._ctx.drawImage(img.canva, -(img.size[0] * ((img.rSize + zFactor))) / 2, -(img.size[0] * ((img.rSize + zFactor))) / 2, (img.size[0] * ((img.rSize + zFactor))), (img.size[0] * ((img.rSize + zFactor))));
            } else {
              // Placeholder: desenhar contorno enquanto modelo n√£o carrega
              this._ctx.drawImage(imgContorno, -(img.size[0] * ((img.rSize + zFactor))) / 2, -(img.size[0] * ((img.rSize + zFactor))) / 2, (img.size[0] * ((img.rSize + zFactor))), (img.size[0] * ((img.rSize + zFactor))));
            }


            if (layer.options.isCtrlPressed || img.showLabel.name || img.showLabel.plate) {
              if (img.rotate) {
                this._ctx.rotate((-img.rotate) * Math.PI / 180);
              }

              if (layer.options.isCtrlPressed || (img.showLabel.name && img.showLabel.plate)) {
                this._ctx.drawImage(img.cachedLabels.all.c, -(img.cachedLabels.all.width) / 2, (img.size[0] * ((img.rSize + zFactor))) - 30);
              } else if (img.showLabel.name) {
                this._ctx.drawImage(img.cachedLabels.name.c, -(img.cachedLabels.name.width) / 2, (img.size[0] * ((img.rSize + zFactor))) - 30);
              } else if (img.showLabel.plate) {
                this._ctx.drawImage(img.cachedLabels.plate.c, -(img.cachedLabels.plate.width) / 2, (img.size[0] * ((img.rSize + zFactor))) - 30);
              }
            }

            this._ctx.restore();

          }
        },
      });


      // eslint-disable-next-line no-unused-vars
      const angleCrds = (map, prevLatlng, latlng) => {
        if (!latlng || !prevLatlng) return 0;
        const pxStart = map.project(prevLatlng);
        const pxEnd = map.project(latlng);
        return Math.atan2(pxStart.y - pxEnd.y, pxStart.x - pxEnd.x) / Math.PI * 180 - 90;
      };

      // eslint-disable-next-line no-unused-vars
      const defaultImgOptions = {
        rotate: 0,
        size: [40, 40],
        offset: { x: 0, y: 0 },
      };

      L.CanvasMarker = L.CircleMarker.extend({
        _containsPoint(p) {
          return p.distanceTo(this._point) <= this._radius - 20;
        },
        _updatePath() {
          this._renderer._updateImg(this);
        },
        updateCanva(d) {
          // FIX: Refer√™ncia a 'this' para retry
          const self = this;


          let car = d.category || 'car';
          let h1 = 0;
          let s1 = 1;  // FIX: Default 1 para saturate
          let b1 = 1.8;
          let h2 = 0;
          let s2 = 1;  // FIX: Default 1 para saturate
          let b2 = 1.8;

          // FIX: Fallback para 'car' se categoria n√£o existe
          if (!bases[car]) {
            car = 'car';
          }
          // FIX: Fallback secundario para 'default' se 'car' tamb√©m n√£o existe
          if (!bases[car]) {
            car = 'default';
          }

          // FIX: Parse tarkan.color com parseFloat e valores default seguros
          if (d.attributes['tarkan.color']) {
            const tmp = d.attributes['tarkan.color'].split("-");
            h1 = parseFloat(tmp[0]) || 0;
            s1 = parseFloat(tmp[1]) || 1;
            b1 = parseFloat(tmp[2]) || 1;
          }
          if (d.attributes['tarkan.color_extra']) {
            const tmp = d.attributes['tarkan.color_extra'].split("-");
            h2 = parseFloat(tmp[0]) || 0;
            s2 = parseFloat(tmp[1]) || 1;
            b2 = parseFloat(tmp[2]) || 1;
          }

          const model = getCachedModel(car, h1, s1, b1, h2, s2, b2);

          // FIX: Se modelo n√£o est√° pronto, agendar retry
          if (model) {
            this.options.img.canva = model;
          } else {
            // Agendar retry em 300ms se modelo ainda n√£o carregou
            setTimeout(function () {
              if (self && self.options && self.updateCanva) {
                self.updateCanva(d);
              }
            }, 300);
          }

          // FIX: Fallback seguro para sizes
          const safeSize = sizes[car] ?? 40;
          this.options.img.size = [safeSize, safeSize];

          this._updatePath();
        },
        statics: {
          notStartedState: 0,
          endedState: 1,
          pausedState: 2,
          runState: 3
        },

        options: {
          autostart: false,
          loop: false,
        },

        initialize: function (latlngs, durations, options) {
          L.CircleMarker.prototype.initialize.call(this, latlngs[0], options);

          // eslint-disable-next-line no-unused-vars
          this._latlngs = latlngs.map(function (e, index) {
            return L.latLng(e);
          });

          if (durations instanceof Array) {
            this._durations = durations;
          } else {
            this._durations = this._createDurations(this._latlngs, durations);
          }

          this._currentDuration = 0;
          this._currentIndex = 0;

          this._state = L.CanvasMarker.notStartedState;
          this._startTime = 0;
          this._startTimeStamp = 0;  // timestamp given by requestAnimFrame
          this._pauseStartTime = 0;
          this._animId = 0;
          this._animRequested = false;
          this._currentLine = [];
          this._stations = {};
        },


        isRunning: function () {
          return this._state === L.CanvasMarker.runState;
        },

        isEnded: function () {
          return this._state === L.CanvasMarker.endedState;
        },

        isStarted: function () {
          return this._state !== L.CanvasMarker.notStartedState;
        },

        isPaused: function () {
          return this._state === L.CanvasMarker.pausedState;
        },

        start: function () {
          if (this.isRunning()) {
            return;
          }

          if (this.isPaused()) {
            this.resume();
          } else {
            this._loadLine(0);
            this._startAnimation();
            this.fire('start');
          }
        },

        resume: function () {
          if (!this.isPaused()) {
            return;
          }
          // update the current line
          this._currentLine[0] = this.getLatLng();
          this._currentDuration -= (this._pauseStartTime - this._startTime);
          this._startAnimation();
        },

        pause: function () {
          if (!this.isRunning()) {
            return;
          }

          this._pauseStartTime = Date.now();
          this._state = L.CanvasMarker.pausedState;
          this._stopAnimation();
          this._updatePosition();
        },

        stop: function (elapsedTime) {
          if (this.isEnded()) {
            return;
          }

          this._stopAnimation();

          if (typeof (elapsedTime) === 'undefined') {
            // user call
            elapsedTime = 0;
            this._updatePosition();
          }

          this._state = L.CanvasMarker.endedState;
          this.fire('end', { elapsedTime: elapsedTime });
        },

        addLatLng: function (latlng, duration) {
          this._latlngs.push(L.latLng(latlng));
          this._durations.push(duration);
        },
        updateStatus: function (s) {
          this._stopAnimation();

          this.options.status = s;

          //console.log(s);
          if (this.options.isCtrlPressed) {
            L.Util.requestAnimFrame(function () {
              this.redraw();
            }, this, false);
          }
        },
        setPressed: function (s) {
          this._stopAnimation();
          if (this.options.isCtrlPressed !== s) {
            this.options.isCtrlPressed = s;

            L.Util.requestAnimFrame(function () {
              this.redraw();
            }, this, false);
          }
        },
        setLabel: function (l) {
          this._stopAnimation();
          this.options.img.showLabel = l;
          L.Util.requestAnimFrame(function () {
            this.redraw();
          }, this, false);
        },
        moveTo: function (latlng, duration) {
          this._stopAnimation();


          if (!this._map || this._map._zoom < 12 || !this._map.getBounds().contains(L.latLng(latlng))) {
            this.setLatLng(latlng);
          } else {
            this._latlngs = [this.getLatLng(), latlng];
            this._durations = [duration];
            this._state = L.CanvasMarker.notStartedState;
            this.start();
            this.options.loop = false;
          }
        },
        addToMap: function () {
          // FIX: Setar flags de visibilidade consistentes
          this._stopAnimation();
          this.options.isVisible = true;
          if (this.options.img) {
            this.options.img.hide = false;
            this.options.img.hidden = false;
          }

          // FIX: Verificar se layer existe antes de adicionar
          if (window.$hiddenLayer) {
            window.$hiddenLayer.addLayer(this);
          } else {
            // Fallback: usar addLayer padr√£o
            addLayer({
              ...props,
              leafletObject: this
            });
          }

          // Redesenhar ap√≥s adicionar
          if (this.redraw) {
            this.redraw();
          }
        },

        // FIX: Adicionar m√©todo removeFromMap consistente
        removeFromMap: function () {
          this._stopAnimation();
          this.options.isVisible = false;
          if (this.options.img) {
            this.options.img.hide = true;
            this.options.img.hidden = true;
          }

          if (window.$hiddenLayer) {
            try {
              window.$hiddenLayer.removeLayer(this);
            } catch (e) {
              // Silenciar erro se layer j√° foi removido
            }
          }

          if (this.redraw) {
            this.redraw();
          }
        },

        addStation: function (pointIndex, duration) {
          if (pointIndex > this._latlngs.length - 2 || pointIndex < 1) {
            return;
          }
          this._stations[pointIndex] = duration;
        },

        onAdd: function (map) {
          L.CircleMarker.prototype.onAdd.call(this, map);

          if (this.options.autostart && (!this.isStarted())) {
            this.start();
            return;
          }

          if (this.isRunning()) {
            this._resumeAnimation();
          }
        },

        onRemove: function (map) {
          L.CircleMarker.prototype.onRemove.call(this, map);
          this._stopAnimation();
        },

        _createDurations: function (latlngs, duration) {
          var lastIndex = latlngs.length - 1;
          var distances = [];
          var totalDistance = 0;
          var distance = 0;

          // compute array of distances between points
          for (var i = 0; i < lastIndex; i++) {
            distance = latlngs[i + 1].distanceTo(latlngs[i]);
            distances.push(distance);
            totalDistance += distance;
          }

          var ratioDuration = duration / totalDistance;

          var durations = [];
          for (i = 0; i < distances.length; i++) {
            durations.push(distances[i] * ratioDuration);
          }

          return durations;
        },

        _startAnimation: function () {
          this._state = L.CanvasMarker.runState;
          this._animId = L.Util.requestAnimFrame(function (timestamp) {
            this._startTime = Date.now();
            this._startTimeStamp = timestamp;
            this._animate(timestamp);
          }, this, true);
          this._animRequested = true;
        },

        _resumeAnimation: function () {
          if (!this._animRequested) {
            this._animRequested = true;
            this._animId = L.Util.requestAnimFrame(function (timestamp) {
              this._animate(timestamp);
            }, this, true);
          }
        },

        _stopAnimation: function () {
          if (this._animRequested) {
            L.Util.cancelAnimFrame(this._animId);
            this._animRequested = false;
          }
        },

        _updatePosition: function () {
          var elapsedTime = Date.now() - this._startTime;
          this._animate(this._startTimeStamp + elapsedTime, true);
        },

        _loadLine: function (index) {
          this._currentIndex = index;
          this._currentDuration = this._durations[index];
          this._currentLine = this._latlngs.slice(index, index + 2);
        },

        /**
         * Load the line where the marker is
         * @param  {Number} timestamp
         * @return {Number} elapsed time on the current line or null if
         * we reached the end or marker is at a station
         */
        _updateLine: function (timestamp) {
          // time elapsed since the last latlng
          var elapsedTime = timestamp - this._startTimeStamp;

          // not enough time to update the line
          if (elapsedTime <= this._currentDuration) {
            return elapsedTime;
          }

          var lineIndex = this._currentIndex;
          var lineDuration = this._currentDuration;
          var stationDuration;

          while (elapsedTime > lineDuration) {
            // substract time of the current line
            elapsedTime -= lineDuration;
            stationDuration = this._stations[lineIndex + 1];

            // test if there is a station at the end of the line
            if (stationDuration !== undefined) {
              if (elapsedTime < stationDuration) {
                this.setLatLng(this._latlngs[lineIndex + 1]);
                return null;
              }
              elapsedTime -= stationDuration;
            }

            lineIndex++;

            // test if we have reached the end of the polyline
            if (lineIndex >= this._latlngs.length - 1) {

              if (this.options.loop) {
                lineIndex = 0;
                this.fire('loop', { elapsedTime: elapsedTime });
              } else {
                // place the marker at the end, else it would be at
                // the last position
                this.setLatLng(this._latlngs[this._latlngs.length - 1]);
                this.stop(elapsedTime);
                return null;
              }
            }
            lineDuration = this._durations[lineIndex];
          }

          this._loadLine(lineIndex);
          this._startTimeStamp = timestamp - elapsedTime;
          this._startTime = Date.now() - elapsedTime;
          return elapsedTime;
        },

        _animate: function (timestamp, noRequestAnim) {
          this._animRequested = false;

          // find the next line and compute the new elapsedTime
          var elapsedTime = this._updateLine(timestamp);

          if (this.isEnded()) {
            // no need to animate
            return;
          }

          if (elapsedTime != null) {
            // compute the position
            var p = L.interpolatePosition(this._currentLine[0],
              this._currentLine[1],
              this._currentDuration,
              elapsedTime);
            this.setLatLng(p);
          }

          if (!noRequestAnim) {
            this._animId = L.Util.requestAnimFrame(this._animate, this, false);
            this._animRequested = true;
          }
        }
      });

      // üéØ HANDSHAKE: Carregar modelos ao final do onMounted
      try {
        await window.loadModels();
        window.__canvasMarkerReady = true; // Flag global
        window.dispatchEvent(new CustomEvent('tarkan:canvasMarkerReady', {
          detail: { loaded: true }
        }));
        console.log('‚úÖ [CanvasMarkerReady] L.CanvasMarker e modelos carregados');
      } catch (err) {
        console.error('‚ùå [CanvasMarkerReady] Erro ao carregar modelos:', err);
      }

      // üéØ CLUSTER: Importar cluster.js DINAMICAMENTE + inicializar window.$mk (projeto argentino)
      if (!window.$mk && typeof L.MarkerClusterGroup === 'undefined') {
        console.log('üîß [CanvaMarker] Importando cluster.js customizado...');
        try {
          await import('./cluster.js');
          console.log('‚úÖ [CanvaMarker] cluster.js carregado com sucesso');
          console.log('üîç [CanvaMarker] L.MarkerClusterGroup dispon√≠vel?', typeof L.MarkerClusterGroup);
        } catch (e) {
          console.error('‚ùå [CanvaMarker] Erro ao carregar cluster.js:', e);
        }
      }
      
      // üõ°Ô∏è VERIFICA√á√ÉO E CRIA√á√ÉO do window.$mk (se n√£o existir)
      if (!window.$mk) {
        if (typeof L.MarkerClusterGroup === 'undefined') {
          console.error('‚ùå [CanvaMarker] L.MarkerClusterGroup n√£o dispon√≠vel ap√≥s import. Clustering DESABILITADO.');
          isClusteredEnabled.value = false;
          window.$mk = null;
          clusterAvailable = false;
        } else {
          // üéØ AGUARDAR o mapa estar 100% pronto
          const mapObj = props.map?.leafletObject;
          if (!mapObj || !mapObj._loaded) {
            console.warn('‚ö†Ô∏è [CanvaMarker] Mapa ainda n√£o est√° carregado, aguardando...');
            await new Promise(resolve => {
              if (mapObj && mapObj._loaded) {
                resolve();
              } else if (mapObj) {
                mapObj.once('load', resolve);
              } else {
                // Fallback: aguardar 500ms
                setTimeout(resolve, 500);
              }
            });
            console.log('‚úÖ [CanvaMarker] Mapa agora est√° pronto');
          }
          
          // üéØ Criar window.$mk com mesma config do projeto argentino
          try {
            console.log('üîß [CanvaMarker] Criando window.$mk...');
            window.$mk = L.markerClusterGroup({
              pane: 'clusterMarkersPane',
              maxClusterRadius: 80,
              spiderfyOnMaxZoom: true,
              singleMarkerMode: false,
              showCoverageOnHover: false,
              zoomToBoundsOnClick: true,
              disableClusteringAtZoom: 17,
              chunkedLoading: true,
              chunkInterval: 200,
              chunkDelay: 50,
              iconCreateFunction: (cluster) => {
                const count = cluster.getChildCount();
                const label = count >= 100 ? "99+" : String(count);
                
                return L.divIcon({
                  html: `<div style="background: rgba(33,150,243,0.92); border: 3px solid rgba(255,255,255,0.9); border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;">
                    <span style="color: white; font-weight: bold; font-size: 14px;">${label}</span>
                  </div>`,
                  className: 'marker-cluster-custom',
                  iconSize: new L.Point(40, 40)
                });
              }
            });
            console.log('‚úÖ [CanvaMarker] window.$mk criado:', window.$mk);
            
            // üéØ CR√çTICO: Adicionar ao mapa (igual projeto argentino)
            if (window.$mk && addLayer) {
              addLayer({ leafletObject: window.$mk });
              console.log('‚úÖ [CanvaMarker] addLayer() chamado');
              
              // üîç DIAGN√ìSTICO: Verificar se _map foi populado
              await nextTick();
              console.log('üîç [CanvaMarker] window.$mk._map:', window.$mk._map);
              console.log('üîç [CanvaMarker] window.$mk._mapPane:', window.$mk._mapPane);
              
              if (!window.$mk._map) {
                console.error('‚ùå [CanvaMarker] window.$mk._map ainda √© NULL ap√≥s addLayer!');
              }
            } else {
              console.error('‚ùå [CanvaMarker] addLayer n√£o dispon√≠vel ou window.$mk inv√°lido');
            }
            
            // üõ°Ô∏è VERIFICA√á√ÉO: APIs dispon√≠veis E _map populado?
            if (!window.$mk || !window.$mk.addLayer || !window.$mk.clearLayers || !window.$mk._map) {
              console.error('‚ùå [CanvaMarker] window.$mk inv√°lido (APIs ou _map missing). Cluster DESABILITADO.');
              console.error('   - addLayer:', !!window.$mk?.addLayer);
              console.error('   - clearLayers:', !!window.$mk?.clearLayers);
              console.error('   - _map:', !!window.$mk?._map);
              isClusteredEnabled.value = false;
              window.$mk = null;
              clusterAvailable = false;
            } else {
              clusterAvailable = true;
              console.log('‚úÖ [CanvaMarker] window.$mk 100% inicializado e vinculado ao mapa');
            }
          } catch (e) {
            console.error('‚ùå [CanvaMarker] Erro ao criar window.$mk:', e);
            isClusteredEnabled.value = false;
            window.$mk = null;
            clusterAvailable = false;
          }
        }
      } else {
        // window.$mk j√° existe (criado antes)
        clusterAvailable = true;
        console.log('‚ôªÔ∏è [CanvaMarker] window.$mk j√° existe, reutilizando');
      }

      debugLog('üéâ [CanvaMarker] onMounted completo - tudo pronto!');
      
      // GATILHO INICIAL: Sincronizar markers se j√° houver devices e mapa
      nextTick(() => {
        const devices = store.state.devices?.deviceList;
        if (devices && devices.length > 0 && props.map) {
          debugLog('üöÄ [CanvaMarker] Sincroniza√ß√£o inicial de markers');
          syncMarkers();
        }
      });
    });




    // üõ°Ô∏è MELHORIA: Valida√ß√£o robusta de device data
    const invalidDevices = { count: 0, ids: [] };
    
    const addDevice = (d) => {
      // Valida√ß√£o defensiva de entrada
      if (!d || typeof d !== 'object') {
        return null;
      }

      const lat = d.latitude;
      const lng = d.longitude;

      // Validar exist√™ncia e tipo
      if (!lat || !lng || isNaN(Number(lat)) || isNaN(Number(lng))) {
        invalidDevices.count++;
        if (invalidDevices.ids.length < 5) { // Armazena apenas os primeiros 5
          invalidDevices.ids.push(d.id || d.name);
        }
        return null;
      }

      // Validar range de coordenadas geogr√°ficas
      if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
        invalidDevices.count++;
        if (invalidDevices.ids.length < 5) {
          invalidDevices.ids.push(d.id || d.name);
        }
        return null;
      }

      // CORRE√á√ÉO: Verificar se L est√° dispon√≠vel (sem bloquear prematuramente)
      if (typeof L === 'undefined') {
        console.warn('[CanvaMarker] Leaflet n√£o dispon√≠vel ainda');
        return null;
      }

      let car = d.category || 'default';
      let h1 = 0;
      let s1 = 1;  // FIX: Default 1 para saturate
      let b1 = 1.8;
      let h2 = 0;
      let s2 = 1;  // FIX: Default 1 para saturate
      let b2 = 1.8;

      // FIX: Fallback duplo
      if (!bases[car]) {
        car = 'car';
      }
      if (!bases[car]) {
        car = 'default';
      }

      // FIX: Corrigido find() - arrow function precisa de return
      const entity = leafletRef.value.find(e => e.options?.id === d.id);


      if (entity) {
        // CLUSTER PATCH: Registrar entity existente no cache
        markerById.value.set(d.id, entity);
        // PATCH 1C: Tamb√©m registrar no deviceMarkerRegistry
        markerRegistry?.set(d.id, entity);
        // Remover console.log excessivo
      } else {

        // FIX: Parse tarkan.color com parseFloat
        if (d.attributes['tarkan.color']) {
          const tmp = d.attributes['tarkan.color'].split("|");
          h1 = parseFloat(tmp[0]) || 0;
          s1 = parseFloat(tmp[1]) || 1;
          b1 = parseFloat(tmp[2]) || 1;
        }
        if (d.attributes['tarkan.color_extra']) {
          const tmp = d.attributes['tarkan.color_extra'].split("|");
          h2 = parseFloat(tmp[0]) || 0;
          s2 = parseFloat(tmp[1]) || 1;
          b2 = parseFloat(tmp[2]) || 1;
        }



        const model = getCachedModel(car, h1, s1, b1, h2, s2, b2);


        const pos = store.getters['devices/getPosition'](d.id);


        const latlng = (pos) ? L.latLng(pos.latitude, pos.longitude) : L.latLng(0, 0)

        // FIX: Fallback seguro para radius e sizes
        const safeRadius = radius[car] ?? 20;
        const safeSize = sizes[car] ?? 40;

        const tmp = new L.CanvasMarker([latlng], [1000], {
          minZoom: 10,
          type: 'car',
          radius: safeRadius + 40,
          id: d.id,
          name: d.name,
          status: d.status,
          isCtrlPressed: false,
          isVisible: true,  // FIX: Flag de visibilidade
          img: {
            canva: model,  // Pode ser null; renderer vai usar placeholder
            showLabel: { name: store.getters['mapPref']('name'), plate: store.getters['mapPref']('plate'), status: store.getters['mapPref']('status') },
            cachedLabels: generateCachedLabel(d),
            hide: false,
            radius: safeRadius + 40,
            hidden: false,
            car: car,
            rSize: 0.5,
            size: [safeSize, safeSize],     //image size ( default [40, 40] )
            rotate: (pos) ? pos.course : 0,         //image base rotate ( default 0 )
            offset: { x: 0, y: 0 }, //image offset ( default { x: 0, y: 0 } )
          },
        }).on("click", (e) => {
          context.emit('click', e);
        }).on("mouseover", (e) => {
          context.emit('mouseover', e);
        }).on("mouseout", (e) => {
          context.emit('mouseout', e);
        }).on("contextmenu", (e) => {
          context.emit('contextmenu', e);
        });

        // PATCH FINAL A: M√©todo __setHidden para hide/show robusto durante playback
        tmp.__setHidden = (hidden) => {
          // Flag √∫nica e confi√°vel no n√≠vel de options
          tmp.options.__hidden = !!hidden;

          // Tamb√©m setar flags em options.img para compatibilidade
          if (tmp.options?.img) {
            tmp.options.img.hidden = !!hidden;
            tmp.options.img.hide = !!hidden;
          }

          // For√ßar redesenho - tentar todos os m√©todos poss√≠veis
          if (typeof tmp.redraw === 'function') tmp.redraw();
          if (typeof tmp._update === 'function') tmp._update();
          if (typeof tmp.update === 'function') tmp.update();
          
          // Se estiver em cluster, for√ßar refresh
          if (window.$mk && typeof window.$mk.refreshClusters === 'function') {
            try { window.$mk.refreshClusters(); } catch (_) { /* ignore */ }
          }
        };

        const methods = {};

        addLayer({
          ...props,
          ...methods,
          leafletObject: tmp
        });


        markerList.value.push(tmp);
        // CLUSTER PATCH: Registrar marker no cache
        markerById.value.set(d.id, tmp);
        // PATCH 1C: Registrar no deviceMarkerRegistry (provide/inject)
        markerRegistry?.set(d.id, tmp);


        return tmp;
      }


    }


    window.loadModels = async () => {

      await loadModel('default', 'default', true, false, 30, 20);

      await loadModel('arrow', 'arrow', true, false, 50, 17);
      await loadModel('person', 'person', true, false, 50, 13);
      await loadModel('animal', 'pet', true, false, 50, 13);
      await loadModel('bicycle', 'bicycle', true, false, 50, 30);

      await loadModel('motorcycle', 'motorcycle', true, true, 65, 30);
      await loadModel('scooter', 'scooter', true, true, 65, 30);


      await loadModel('car', 'carroPasseio', true, false, 50, 25);
      await loadModel('pickup', 'carroUtilitario', true, false, 55, 25);

      await loadModel('van', 'vanUtilitario', true, false, 55, 25);
      await loadModel('truck', 'caminhaoBau', true, true, 95, 40);

      await loadModel('truck2', 'truckBau', true, true, 90, 55);
      await loadModel('truck1', 'truckCavalo', true, false, 75, 45);


      await loadModel('tractor', 'tractor', true, false, 55, 32);

      await loadModel('boat', 'boat', true, false, 70, 40);
      await loadModel('ship', 'ship', true, false, 110, 55);
      await loadModel('bus', 'bus', true, false, 75, 48);
      await loadModel('train', 'bus', true, false, 110, 50);
      await loadModel('tram', 'bus', true, false, 110, 50);
      await loadModel('trolleybus', 'bus', true, false, 110, 50);


      await loadModel('crane', 'crane', true, false, 110, 55);


      await loadModel('plane', 'plane', true, false, 100, 60);
      await loadModel('helicopter', 'helicopter', true, false, 100, 60);
      await loadModel('offroad', 'offroad', true, false, 70, 30);
    }

    window.addDevice = addDevice;
    provide('addDevice', addDevice);

    // CLUSTER PATCH: Watch para sincroniza√ß√£o autom√°tica
    // Observar mudan√ßas na lista de devices
    watch(
      () => store.state.devices?.deviceList,
      (newList) => {
        if (newList) {
          syncMarkers();
        }
      }
    );

    // Watch para atualiza√ß√£o de posi√ß√µes (essencial para mover markers)
    watch(
      () => store.state.devices?.positionsList,
      () => {
        // For√ßar atualiza√ß√£o visual dos markers existentes
        syncMarkers();
      },
      { deep: true }
    );

    // Watch separado para clustered e zoom
    watch(
      () => [isClusteredEnabled.value, props.zoom],
      () => {
        syncMarkers();
      }
    );

    // Watch unificado para o mapa - aguarda inicializa√ß√£o completa
    watch(
      () => props.map,
      (mapProxy) => {
        if (!mapProxy) return;
        
        // CORRE√á√ÉO: Pegar leafletObject (L.Map nativo)
        const map = mapProxy.leafletObject || mapProxy;
        if (!map || typeof map.on !== 'function') {
          console.warn('[CanvaMarker] map.leafletObject n√£o dispon√≠vel ainda');
          return;
        }

        // Aguardar mapa estar 100% pronto antes de sincronizar
        if (map.whenReady) {
          map.whenReady(() => {
            debugLog('üó∫Ô∏è [CanvaMarker] Mapa pronto, iniciando syncMarkers');
            syncMarkers();
            
            // For√ßar invalidateSize
            nextTick(() => {
              if (map?.invalidateSize) {
                map.invalidateSize(true);
              }
            });
          });
        } else {
          // Fallback se whenReady n√£o estiver dispon√≠vel
          syncMarkers();
        }

        // Registrar listeners de moveend/zoomend
        const onMoveEnd = () => { if (isClusteredEnabled.value) syncMarkers(); };
        map.on("moveend", onMoveEnd);
        map.on("zoomend", onMoveEnd);

        // Cleanup ser√° feito no onBeforeUnmount principal
      }
    );

    onBeforeUnmount(() => {
      debugLog('üßπ [CanvaMarker] Cleanup iniciado');
      
      // Limpar timeout de sync pendente
      if (syncTimeout) {
        clearTimeout(syncTimeout);
        syncTimeout = null;
      }
      
      // Remover event listeners do mapa
      const mapProxy = props.map;
      if (mapProxy) {
        const map = mapProxy.leafletObject || mapProxy;
        if (map && typeof map.off === 'function') {
          try {
            map.off("moveend");
            map.off("zoomend");
          } catch (e) { /* cleanup */ }
        }
      }
      
      // Limpar todos os markers
      clearAllMarkers();
      
      debugLog('‚úÖ [CanvaMarker] Cleanup completo');
    });

  },
  render() {

    //console.log("Kore is rendering...")

    return null;
  }



}

</script>